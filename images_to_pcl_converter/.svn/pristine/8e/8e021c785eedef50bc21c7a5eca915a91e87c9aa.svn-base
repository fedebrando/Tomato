#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/image.hpp"
#include "sensor_msgs/msg/camera_info.hpp"
#include "sensor_msgs/msg/point_cloud2.hpp"
#include "message_filters/subscriber.h"
#include "message_filters/time_synchronizer.h"
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>
#include <std_srvs/srv/trigger.hpp>

using std::placeholders::_1;
using std::placeholders::_2;

class SynchronizedImageSubscriberNode : public rclcpp::Node
{
public:
    SynchronizedImageSubscriberNode() : Node("images_to_pcl_converter_node")
    {
        ref_link_ = this->declare_parameter<std::string>("ref_link", "");
        std::string camera_info_topic = this->declare_parameter<std::string>("camera_info_topic", "");
        std::string pcl_topic = this->declare_parameter<std::string>("pcl_topic", "");
        std::string rgb_topic = this->declare_parameter<std::string>("rgb_topic", "");
        std::string depth_topic = this->declare_parameter<std::string>("depth_topic", "");

        // Subscribe to RGB image topic
        rgb_image_sub_.subscribe(this, rgb_topic);

        // Subscribe to depth image topic
        depth_image_sub_.subscribe(this, depth_topic);

        // Subscribe to camera info topic
        camera_info_sub_ = this->create_subscription<sensor_msgs::msg::CameraInfo>(
            camera_info_topic, 10, std::bind(&SynchronizedImageSubscriberNode::cameraInfoCallback, this, std::placeholders::_1));

        // Synchronize RGB, depth images, and camera info based on timestamps
        sync_ = std::make_shared<message_filters::TimeSynchronizer<sensor_msgs::msg::Image, sensor_msgs::msg::Image>>(
            rgb_image_sub_, depth_image_sub_, 10);
        sync_->registerCallback(&SynchronizedImageSubscriberNode::imageCallback, this);

        // Publisher for the RGB point cloud
        rgb_pointcloud_pub_ = this->create_publisher<sensor_msgs::msg::PointCloud2>(pcl_topic, 10);

        // Services that can be used to start/stop the publishing of pcl
        start_pub_pcl_service_ = this->create_service<std_srvs::srv::Trigger>("start_pub_pcl", std::bind(&SynchronizedImageSubscriberNode::start_pub_pcl, this, _1, _2));
        stop_pub_pcl_service_ = this->create_service<std_srvs::srv::Trigger>("stop_pub_pcl", std::bind(&SynchronizedImageSubscriberNode::stop_pub_pcl, this, _1, _2));
    }

private:
    void imageCallback(const sensor_msgs::msg::Image::SharedPtr rgb_msg, const sensor_msgs::msg::Image::SharedPtr depth_msg)
    {

        if (!camera_info_available or !publish_pcl)
            return;

        // Process synchronized RGB and depth images and camera info here
        // Access RGB image data using rgb_msg->data, rgb_msg->width, rgb_msg->height, etc.
        // Access depth image data using depth_msg->data, depth_msg->width, depth_msg->height, etc.
        // Access camera parameters using camera_info->D, camera_info->K, camera_info->P, etc.

        // Generate RGB point cloud using PCL
        pcl::PointCloud<pcl::PointXYZRGB>::Ptr point_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
        point_cloud->width = depth_msg->width;
        point_cloud->height = depth_msg->height;
        point_cloud->is_dense = false;
        point_cloud->points.resize(point_cloud->width * point_cloud->height);

        double fx = camera_info_.k[0];
        double fy = camera_info_.k[4];
        double cx = camera_info_.k[2];
        double cy = camera_info_.k[5];

        // Assuming RGB and depth images are in the same resolution
        int k = 0;
        for (uint v = 0; v < rgb_msg->height; ++v)
        {
            for (uint u = 0; u < rgb_msg->width; ++u, ++k)
            {

                pcl::PointXYZRGB& pt = point_cloud->points[k];

                // Access RGB and depth values
                uint8_t r = rgb_msg->data[(v * rgb_msg->width + u) * 3];
                uint8_t g = rgb_msg->data[(v * rgb_msg->width + u) * 3 + 1];
                uint8_t b = rgb_msg->data[(v * rgb_msg->width + u) * 3 + 2];
                float depth = *reinterpret_cast<const uint16_t *>(&depth_msg->data[(v * rgb_msg->width + u) * 2]);

                // Convert pixel coordinates to 3D point
                pt.z = depth / 1000.;
                pt.x = (static_cast<float>(u) - cx) * pt.z / fx;
                pt.y = (static_cast<float>(v) - cy) * pt.z / fy;

                pt.r = r;
                pt.g = g;
                pt.b = b;
            }
        }

        // Publish the generated point cloud
        sensor_msgs::msg::PointCloud2::SharedPtr cloud_msg(new sensor_msgs::msg::PointCloud2);
        pcl::toROSMsg(*point_cloud, *cloud_msg);
        cloud_msg->header.frame_id = ref_link_;
        cloud_msg->header.stamp = rclcpp::Time(rgb_msg->header.stamp);
        rgb_pointcloud_pub_->publish(*cloud_msg);
    }

    void cameraInfoCallback(const sensor_msgs::msg::CameraInfo::SharedPtr camera_info)
    {
        // Process camera info as needed
        // Access camera parameters using camera_info->D, camera_info->K, camera_info->P, etc.
        if (!camera_info_available)
        {
            camera_info_available = true;
            camera_info_ = *camera_info.get();
        }
    }

    void start_pub_pcl(const std::shared_ptr<std_srvs::srv::Trigger::Request> request, std::shared_ptr<std_srvs::srv::Trigger::Response> response){
        (void) request;
        (void) response;
        publish_pcl = true;
    }

    void stop_pub_pcl(const std::shared_ptr<std_srvs::srv::Trigger::Request> request, std::shared_ptr<std_srvs::srv::Trigger::Response> response){
        (void) request;
        (void) response;
        publish_pcl = false;
    }

    message_filters::Subscriber<sensor_msgs::msg::Image> rgb_image_sub_;
    message_filters::Subscriber<sensor_msgs::msg::Image> depth_image_sub_;
    rclcpp::Subscription<sensor_msgs::msg::CameraInfo>::SharedPtr camera_info_sub_;
    bool camera_info_available = false;
    sensor_msgs::msg::CameraInfo camera_info_;
    std::shared_ptr<message_filters::TimeSynchronizer<sensor_msgs::msg::Image, sensor_msgs::msg::Image>> sync_;
    rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr rgb_pointcloud_pub_;
    rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr start_pub_pcl_service_;
    rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr stop_pub_pcl_service_;
    bool publish_pcl = true;
    std::string ref_link_;
};

int main(int argc, char **argv)
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<SynchronizedImageSubscriberNode>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
